"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.de_StartConversationCommand = exports.de_RecognizeUtteranceCommand = exports.de_RecognizeTextCommand = exports.de_PutSessionCommand = exports.de_GetSessionCommand = exports.de_DeleteSessionCommand = exports.se_StartConversationCommand = exports.se_RecognizeUtteranceCommand = exports.se_RecognizeTextCommand = exports.se_PutSessionCommand = exports.se_GetSessionCommand = exports.se_DeleteSessionCommand = void 0;
const protocol_http_1 = require("@smithy/protocol-http");
const smithy_client_1 = require("@smithy/smithy-client");
const LexRuntimeV2ServiceException_1 = require("../models/LexRuntimeV2ServiceException");
const models_0_1 = require("../models/models_0");
const se_DeleteSessionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "botId", () => input.botId, "{botId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "botAliasId", () => input.botAliasId, "{botAliasId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "localeId", () => input.localeId, "{localeId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "sessionId", () => input.sessionId, "{sessionId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteSessionCommand = se_DeleteSessionCommand;
const se_GetSessionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "botId", () => input.botId, "{botId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "botAliasId", () => input.botAliasId, "{botAliasId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "localeId", () => input.localeId, "{localeId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "sessionId", () => input.sessionId, "{sessionId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetSessionCommand = se_GetSessionCommand;
const se_PutSessionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        responsecontenttype: input.responseContentType,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "botId", () => input.botId, "{botId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "botAliasId", () => input.botAliasId, "{botAliasId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "localeId", () => input.localeId, "{localeId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "sessionId", () => input.sessionId, "{sessionId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        messages: (_) => (0, smithy_client_1._json)(_),
        requestAttributes: (_) => (0, smithy_client_1._json)(_),
        sessionState: (_) => se_SessionState(_, context),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_PutSessionCommand = se_PutSessionCommand;
const se_RecognizeTextCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}/text";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "botId", () => input.botId, "{botId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "botAliasId", () => input.botAliasId, "{botAliasId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "localeId", () => input.localeId, "{localeId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "sessionId", () => input.sessionId, "{sessionId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        requestAttributes: (_) => (0, smithy_client_1._json)(_),
        sessionState: (_) => se_SessionState(_, context),
        text: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_RecognizeTextCommand = se_RecognizeTextCommand;
const se_RecognizeUtteranceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "x-amz-content-sha256": "UNSIGNED-PAYLOAD",
        "content-type": input.requestContentType || "application/octet-stream",
        "x-amz-lex-session-state": input.sessionState,
        "x-amz-lex-request-attributes": input.requestAttributes,
        "response-content-type": input.responseContentType,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}/utterance";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "botId", () => input.botId, "{botId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "botAliasId", () => input.botAliasId, "{botAliasId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "localeId", () => input.localeId, "{localeId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "sessionId", () => input.sessionId, "{sessionId}", false);
    let body;
    if (input.inputStream !== undefined) {
        body = input.inputStream;
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_RecognizeUtteranceCommand = se_RecognizeUtteranceCommand;
const se_StartConversationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "x-amz-lex-conversation-mode": input.conversationMode,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}/conversation";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "botId", () => input.botId, "{botId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "botAliasId", () => input.botAliasId, "{botAliasId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "localeId", () => input.localeId, "{localeId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "sessionId", () => input.sessionId, "{sessionId}", false);
    let body;
    if (input.requestEventStream !== undefined) {
        body = se_StartConversationRequestEventStream(input.requestEventStream, context);
    }
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_StartConversationCommand = se_StartConversationCommand;
const de_DeleteSessionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteSessionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        botAliasId: smithy_client_1.expectString,
        botId: smithy_client_1.expectString,
        localeId: smithy_client_1.expectString,
        sessionId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DeleteSessionCommand = de_DeleteSessionCommand;
const de_DeleteSessionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.lexruntimev2#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.lexruntimev2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.lexruntimev2#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.lexruntimev2#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.lexruntimev2#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.lexruntimev2#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetSessionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetSessionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        interpretations: (_) => de_Interpretations(_, context),
        messages: smithy_client_1._json,
        sessionId: smithy_client_1.expectString,
        sessionState: (_) => de_SessionState(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetSessionCommand = de_GetSessionCommand;
const de_GetSessionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.lexruntimev2#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.lexruntimev2#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.lexruntimev2#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.lexruntimev2#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.lexruntimev2#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_PutSessionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutSessionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        contentType: [, output.headers["content-type"]],
        messages: [, output.headers["x-amz-lex-messages"]],
        sessionState: [, output.headers["x-amz-lex-session-state"]],
        requestAttributes: [, output.headers["x-amz-lex-request-attributes"]],
        sessionId: [, output.headers["x-amz-lex-session-id"]],
    });
    const data = output.body;
    context.sdkStreamMixin(data);
    contents.audioStream = data;
    return contents;
};
exports.de_PutSessionCommand = de_PutSessionCommand;
const de_PutSessionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.lexruntimev2#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadGatewayException":
        case "com.amazonaws.lexruntimev2#BadGatewayException":
            throw await de_BadGatewayExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.lexruntimev2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "DependencyFailedException":
        case "com.amazonaws.lexruntimev2#DependencyFailedException":
            throw await de_DependencyFailedExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.lexruntimev2#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.lexruntimev2#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.lexruntimev2#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.lexruntimev2#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_RecognizeTextCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RecognizeTextCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        interpretations: (_) => de_Interpretations(_, context),
        messages: smithy_client_1._json,
        recognizedBotMember: smithy_client_1._json,
        requestAttributes: smithy_client_1._json,
        sessionId: smithy_client_1.expectString,
        sessionState: (_) => de_SessionState(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_RecognizeTextCommand = de_RecognizeTextCommand;
const de_RecognizeTextCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.lexruntimev2#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadGatewayException":
        case "com.amazonaws.lexruntimev2#BadGatewayException":
            throw await de_BadGatewayExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.lexruntimev2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "DependencyFailedException":
        case "com.amazonaws.lexruntimev2#DependencyFailedException":
            throw await de_DependencyFailedExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.lexruntimev2#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.lexruntimev2#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.lexruntimev2#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.lexruntimev2#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_RecognizeUtteranceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RecognizeUtteranceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
        inputMode: [, output.headers["x-amz-lex-input-mode"]],
        contentType: [, output.headers["content-type"]],
        messages: [, output.headers["x-amz-lex-messages"]],
        interpretations: [, output.headers["x-amz-lex-interpretations"]],
        sessionState: [, output.headers["x-amz-lex-session-state"]],
        requestAttributes: [, output.headers["x-amz-lex-request-attributes"]],
        sessionId: [, output.headers["x-amz-lex-session-id"]],
        inputTranscript: [, output.headers["x-amz-lex-input-transcript"]],
        recognizedBotMember: [, output.headers["x-amz-lex-recognized-bot-member"]],
    });
    const data = output.body;
    context.sdkStreamMixin(data);
    contents.audioStream = data;
    return contents;
};
exports.de_RecognizeUtteranceCommand = de_RecognizeUtteranceCommand;
const de_RecognizeUtteranceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.lexruntimev2#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadGatewayException":
        case "com.amazonaws.lexruntimev2#BadGatewayException":
            throw await de_BadGatewayExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.lexruntimev2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "DependencyFailedException":
        case "com.amazonaws.lexruntimev2#DependencyFailedException":
            throw await de_DependencyFailedExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.lexruntimev2#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.lexruntimev2#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.lexruntimev2#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.lexruntimev2#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_StartConversationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_StartConversationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = output.body;
    contents.responseEventStream = de_StartConversationResponseEventStream(data, context);
    return contents;
};
exports.de_StartConversationCommand = de_StartConversationCommand;
const de_StartConversationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.lexruntimev2#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.lexruntimev2#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.lexruntimev2#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.lexruntimev2#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = (0, smithy_client_1.withBaseException)(LexRuntimeV2ServiceException_1.LexRuntimeV2ServiceException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_BadGatewayExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.BadGatewayException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_DependencyFailedExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.DependencyFailedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const se_StartConversationRequestEventStream = (input, context) => {
    const eventMarshallingVisitor = (event) => models_0_1.StartConversationRequestEventStream.visit(event, {
        ConfigurationEvent: (value) => se_ConfigurationEvent_event(value, context),
        AudioInputEvent: (value) => se_AudioInputEvent_event(value, context),
        DTMFInputEvent: (value) => se_DTMFInputEvent_event(value, context),
        TextInputEvent: (value) => se_TextInputEvent_event(value, context),
        PlaybackCompletionEvent: (value) => se_PlaybackCompletionEvent_event(value, context),
        DisconnectionEvent: (value) => se_DisconnectionEvent_event(value, context),
        _: (value) => value,
    });
    return context.eventStreamMarshaller.serialize(input, eventMarshallingVisitor);
};
const se_AudioInputEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "AudioInputEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/json" },
    };
    let body = new Uint8Array();
    body = se_AudioInputEvent(input, context);
    body = context.utf8Decoder(JSON.stringify(body));
    return { headers, body };
};
const se_ConfigurationEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "ConfigurationEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/json" },
    };
    let body = new Uint8Array();
    body = se_ConfigurationEvent(input, context);
    body = context.utf8Decoder(JSON.stringify(body));
    return { headers, body };
};
const se_DisconnectionEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "DisconnectionEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/json" },
    };
    let body = new Uint8Array();
    body = (0, smithy_client_1._json)(input);
    body = context.utf8Decoder(JSON.stringify(body));
    return { headers, body };
};
const se_DTMFInputEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "DTMFInputEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/json" },
    };
    let body = new Uint8Array();
    body = (0, smithy_client_1._json)(input);
    body = context.utf8Decoder(JSON.stringify(body));
    return { headers, body };
};
const se_PlaybackCompletionEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "PlaybackCompletionEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/json" },
    };
    let body = new Uint8Array();
    body = (0, smithy_client_1._json)(input);
    body = context.utf8Decoder(JSON.stringify(body));
    return { headers, body };
};
const se_TextInputEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "TextInputEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/json" },
    };
    let body = new Uint8Array();
    body = (0, smithy_client_1._json)(input);
    body = context.utf8Decoder(JSON.stringify(body));
    return { headers, body };
};
const de_StartConversationResponseEventStream = (output, context) => {
    return context.eventStreamMarshaller.deserialize(output, async (event) => {
        if (event["PlaybackInterruptionEvent"] != null) {
            return {
                PlaybackInterruptionEvent: await de_PlaybackInterruptionEvent_event(event["PlaybackInterruptionEvent"], context),
            };
        }
        if (event["TranscriptEvent"] != null) {
            return {
                TranscriptEvent: await de_TranscriptEvent_event(event["TranscriptEvent"], context),
            };
        }
        if (event["IntentResultEvent"] != null) {
            return {
                IntentResultEvent: await de_IntentResultEvent_event(event["IntentResultEvent"], context),
            };
        }
        if (event["TextResponseEvent"] != null) {
            return {
                TextResponseEvent: await de_TextResponseEvent_event(event["TextResponseEvent"], context),
            };
        }
        if (event["AudioResponseEvent"] != null) {
            return {
                AudioResponseEvent: await de_AudioResponseEvent_event(event["AudioResponseEvent"], context),
            };
        }
        if (event["HeartbeatEvent"] != null) {
            return {
                HeartbeatEvent: await de_HeartbeatEvent_event(event["HeartbeatEvent"], context),
            };
        }
        if (event["AccessDeniedException"] != null) {
            return {
                AccessDeniedException: await de_AccessDeniedException_event(event["AccessDeniedException"], context),
            };
        }
        if (event["ResourceNotFoundException"] != null) {
            return {
                ResourceNotFoundException: await de_ResourceNotFoundException_event(event["ResourceNotFoundException"], context),
            };
        }
        if (event["ValidationException"] != null) {
            return {
                ValidationException: await de_ValidationException_event(event["ValidationException"], context),
            };
        }
        if (event["ThrottlingException"] != null) {
            return {
                ThrottlingException: await de_ThrottlingException_event(event["ThrottlingException"], context),
            };
        }
        if (event["InternalServerException"] != null) {
            return {
                InternalServerException: await de_InternalServerException_event(event["InternalServerException"], context),
            };
        }
        if (event["ConflictException"] != null) {
            return {
                ConflictException: await de_ConflictException_event(event["ConflictException"], context),
            };
        }
        if (event["DependencyFailedException"] != null) {
            return {
                DependencyFailedException: await de_DependencyFailedException_event(event["DependencyFailedException"], context),
            };
        }
        if (event["BadGatewayException"] != null) {
            return {
                BadGatewayException: await de_BadGatewayException_event(event["BadGatewayException"], context),
            };
        }
        return { $unknown: output };
    });
};
const de_AccessDeniedException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_AccessDeniedExceptionRes(parsedOutput, context);
};
const de_AudioResponseEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, de_AudioResponseEvent(data, context));
    return contents;
};
const de_BadGatewayException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_BadGatewayExceptionRes(parsedOutput, context);
};
const de_ConflictException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_ConflictExceptionRes(parsedOutput, context);
};
const de_DependencyFailedException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_DependencyFailedExceptionRes(parsedOutput, context);
};
const de_HeartbeatEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, (0, smithy_client_1._json)(data));
    return contents;
};
const de_IntentResultEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, de_IntentResultEvent(data, context));
    return contents;
};
const de_InternalServerException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_InternalServerExceptionRes(parsedOutput, context);
};
const de_PlaybackInterruptionEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, (0, smithy_client_1._json)(data));
    return contents;
};
const de_ResourceNotFoundException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_ResourceNotFoundExceptionRes(parsedOutput, context);
};
const de_TextResponseEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, (0, smithy_client_1._json)(data));
    return contents;
};
const de_ThrottlingException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_ThrottlingExceptionRes(parsedOutput, context);
};
const de_TranscriptEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, (0, smithy_client_1._json)(data));
    return contents;
};
const de_ValidationException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_ValidationExceptionRes(parsedOutput, context);
};
const se_AudioInputEvent = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        audioChunk: context.base64Encoder,
        clientTimestampMillis: [],
        contentType: [],
        eventId: [],
    });
};
const se_ConfigurationEvent = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        clientTimestampMillis: [],
        disablePlayback: [],
        eventId: [],
        requestAttributes: smithy_client_1._json,
        responseContentType: [],
        sessionState: (_) => se_SessionState(_, context),
        welcomeMessages: smithy_client_1._json,
    });
};
const se_DialogAction = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        slotElicitationStyle: [],
        slotToElicit: [],
        subSlotToElicit: (_) => se_ElicitSubSlot(_, context),
        type: [],
    });
};
const se_ElicitSubSlot = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        name: [],
        subSlotToElicit: (_) => se_ElicitSubSlot(_, context),
    });
};
const se_Intent = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        confirmationState: [],
        name: [],
        slots: (_) => se_Slots(_, context),
        state: [],
    });
};
const se_RuntimeHintDetails = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        runtimeHintValues: smithy_client_1._json,
        subSlotHints: (_) => se_SlotHintsSlotMap(_, context),
    });
};
const se_RuntimeHints = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        slotHints: (_) => se_SlotHintsIntentMap(_, context),
    });
};
const se_SessionState = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        activeContexts: smithy_client_1._json,
        dialogAction: (_) => se_DialogAction(_, context),
        intent: (_) => se_Intent(_, context),
        originatingRequestId: [],
        runtimeHints: (_) => se_RuntimeHints(_, context),
        sessionAttributes: smithy_client_1._json,
    });
};
const se_Slot = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        shape: [],
        subSlots: (_) => se_Slots(_, context),
        value: smithy_client_1._json,
        values: (_) => se_Values(_, context),
    });
};
const se_SlotHintsIntentMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_SlotHintsSlotMap(value, context);
        return acc;
    }, {});
};
const se_SlotHintsSlotMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_RuntimeHintDetails(value, context);
        return acc;
    }, {});
};
const se_Slots = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_Slot(value, context);
        return acc;
    }, {});
};
const se_Values = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Slot(entry, context);
    });
};
const de_AudioResponseEvent = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        audioChunk: context.base64Decoder,
        contentType: smithy_client_1.expectString,
        eventId: smithy_client_1.expectString,
    });
};
const de_ConfidenceScore = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        score: smithy_client_1.limitedParseDouble,
    });
};
const de_DialogAction = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        slotElicitationStyle: smithy_client_1.expectString,
        slotToElicit: smithy_client_1.expectString,
        subSlotToElicit: (_) => de_ElicitSubSlot(_, context),
        type: smithy_client_1.expectString,
    });
};
const de_ElicitSubSlot = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        name: smithy_client_1.expectString,
        subSlotToElicit: (_) => de_ElicitSubSlot(_, context),
    });
};
const de_Intent = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        confirmationState: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
        slots: (_) => de_Slots(_, context),
        state: smithy_client_1.expectString,
    });
};
const de_IntentResultEvent = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        eventId: smithy_client_1.expectString,
        inputMode: smithy_client_1.expectString,
        interpretations: (_) => de_Interpretations(_, context),
        recognizedBotMember: smithy_client_1._json,
        requestAttributes: smithy_client_1._json,
        sessionId: smithy_client_1.expectString,
        sessionState: (_) => de_SessionState(_, context),
    });
};
const de_Interpretation = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        intent: (_) => de_Intent(_, context),
        nluConfidence: (_) => de_ConfidenceScore(_, context),
        sentimentResponse: (_) => de_SentimentResponse(_, context),
    });
};
const de_Interpretations = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Interpretation(entry, context);
    });
    return retVal;
};
const de_RuntimeHintDetails = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        runtimeHintValues: smithy_client_1._json,
        subSlotHints: (_) => de_SlotHintsSlotMap(_, context),
    });
};
const de_RuntimeHints = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        slotHints: (_) => de_SlotHintsIntentMap(_, context),
    });
};
const de_SentimentResponse = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        sentiment: smithy_client_1.expectString,
        sentimentScore: (_) => de_SentimentScore(_, context),
    });
};
const de_SentimentScore = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        mixed: smithy_client_1.limitedParseDouble,
        negative: smithy_client_1.limitedParseDouble,
        neutral: smithy_client_1.limitedParseDouble,
        positive: smithy_client_1.limitedParseDouble,
    });
};
const de_SessionState = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        activeContexts: smithy_client_1._json,
        dialogAction: (_) => de_DialogAction(_, context),
        intent: (_) => de_Intent(_, context),
        originatingRequestId: smithy_client_1.expectString,
        runtimeHints: (_) => de_RuntimeHints(_, context),
        sessionAttributes: smithy_client_1._json,
    });
};
const de_Slot = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        shape: smithy_client_1.expectString,
        subSlots: (_) => de_Slots(_, context),
        value: smithy_client_1._json,
        values: (_) => de_Values(_, context),
    });
};
const de_SlotHintsIntentMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_SlotHintsSlotMap(value, context);
        return acc;
    }, {});
};
const de_SlotHintsSlotMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_RuntimeHintDetails(value, context);
        return acc;
    }, {});
};
const de_Slots = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_Slot(value, context);
        return acc;
    }, {});
};
const de_Values = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Slot(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
