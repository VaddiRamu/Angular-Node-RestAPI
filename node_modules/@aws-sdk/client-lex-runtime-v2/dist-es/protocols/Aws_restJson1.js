import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectNonNull as __expectNonNull, expectObject as __expectObject, expectString as __expectString, limitedParseDouble as __limitedParseDouble, map, resolvedPath as __resolvedPath, take, withBaseException, } from "@smithy/smithy-client";
import { LexRuntimeV2ServiceException as __BaseException } from "../models/LexRuntimeV2ServiceException";
import { AccessDeniedException, BadGatewayException, ConflictException, DependencyFailedException, InternalServerException, ResourceNotFoundException, StartConversationRequestEventStream, ThrottlingException, ValidationException, } from "../models/models_0";
export const se_DeleteSessionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "botId", () => input.botId, "{botId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "botAliasId", () => input.botAliasId, "{botAliasId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "localeId", () => input.localeId, "{localeId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "sessionId", () => input.sessionId, "{sessionId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_GetSessionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "botId", () => input.botId, "{botId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "botAliasId", () => input.botAliasId, "{botAliasId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "localeId", () => input.localeId, "{localeId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "sessionId", () => input.sessionId, "{sessionId}", false);
    let body;
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_PutSessionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        responsecontenttype: input.responseContentType,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}";
    resolvedPath = __resolvedPath(resolvedPath, input, "botId", () => input.botId, "{botId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "botAliasId", () => input.botAliasId, "{botAliasId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "localeId", () => input.localeId, "{localeId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "sessionId", () => input.sessionId, "{sessionId}", false);
    let body;
    body = JSON.stringify(take(input, {
        messages: (_) => _json(_),
        requestAttributes: (_) => _json(_),
        sessionState: (_) => se_SessionState(_, context),
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_RecognizeTextCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}/text";
    resolvedPath = __resolvedPath(resolvedPath, input, "botId", () => input.botId, "{botId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "botAliasId", () => input.botAliasId, "{botAliasId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "localeId", () => input.localeId, "{localeId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "sessionId", () => input.sessionId, "{sessionId}", false);
    let body;
    body = JSON.stringify(take(input, {
        requestAttributes: (_) => _json(_),
        sessionState: (_) => se_SessionState(_, context),
        text: [],
    }));
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_RecognizeUtteranceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-content-sha256": "UNSIGNED-PAYLOAD",
        "content-type": input.requestContentType || "application/octet-stream",
        "x-amz-lex-session-state": input.sessionState,
        "x-amz-lex-request-attributes": input.requestAttributes,
        "response-content-type": input.responseContentType,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}/utterance";
    resolvedPath = __resolvedPath(resolvedPath, input, "botId", () => input.botId, "{botId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "botAliasId", () => input.botAliasId, "{botAliasId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "localeId", () => input.localeId, "{localeId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "sessionId", () => input.sessionId, "{sessionId}", false);
    let body;
    if (input.inputStream !== undefined) {
        body = input.inputStream;
    }
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const se_StartConversationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = map({}, isSerializableHeaderValue, {
        "x-amz-lex-conversation-mode": input.conversationMode,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/bots/{botId}/botAliases/{botAliasId}/botLocales/{localeId}/sessions/{sessionId}/conversation";
    resolvedPath = __resolvedPath(resolvedPath, input, "botId", () => input.botId, "{botId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "botAliasId", () => input.botAliasId, "{botAliasId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "localeId", () => input.localeId, "{localeId}", false);
    resolvedPath = __resolvedPath(resolvedPath, input, "sessionId", () => input.sessionId, "{sessionId}", false);
    let body;
    if (input.requestEventStream !== undefined) {
        body = se_StartConversationRequestEventStream(input.requestEventStream, context);
    }
    return new __HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
export const de_DeleteSessionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteSessionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        botAliasId: __expectString,
        botId: __expectString,
        localeId: __expectString,
        sessionId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_DeleteSessionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.lexruntimev2#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.lexruntimev2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.lexruntimev2#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.lexruntimev2#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.lexruntimev2#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.lexruntimev2#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_GetSessionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetSessionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        interpretations: (_) => de_Interpretations(_, context),
        messages: _json,
        sessionId: __expectString,
        sessionState: (_) => de_SessionState(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_GetSessionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.lexruntimev2#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.lexruntimev2#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.lexruntimev2#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.lexruntimev2#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.lexruntimev2#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_PutSessionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutSessionCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        contentType: [, output.headers["content-type"]],
        messages: [, output.headers["x-amz-lex-messages"]],
        sessionState: [, output.headers["x-amz-lex-session-state"]],
        requestAttributes: [, output.headers["x-amz-lex-request-attributes"]],
        sessionId: [, output.headers["x-amz-lex-session-id"]],
    });
    const data = output.body;
    context.sdkStreamMixin(data);
    contents.audioStream = data;
    return contents;
};
const de_PutSessionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.lexruntimev2#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadGatewayException":
        case "com.amazonaws.lexruntimev2#BadGatewayException":
            throw await de_BadGatewayExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.lexruntimev2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "DependencyFailedException":
        case "com.amazonaws.lexruntimev2#DependencyFailedException":
            throw await de_DependencyFailedExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.lexruntimev2#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.lexruntimev2#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.lexruntimev2#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.lexruntimev2#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_RecognizeTextCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RecognizeTextCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        interpretations: (_) => de_Interpretations(_, context),
        messages: _json,
        recognizedBotMember: _json,
        requestAttributes: _json,
        sessionId: __expectString,
        sessionState: (_) => de_SessionState(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_RecognizeTextCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.lexruntimev2#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadGatewayException":
        case "com.amazonaws.lexruntimev2#BadGatewayException":
            throw await de_BadGatewayExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.lexruntimev2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "DependencyFailedException":
        case "com.amazonaws.lexruntimev2#DependencyFailedException":
            throw await de_DependencyFailedExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.lexruntimev2#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.lexruntimev2#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.lexruntimev2#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.lexruntimev2#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_RecognizeUtteranceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RecognizeUtteranceCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        inputMode: [, output.headers["x-amz-lex-input-mode"]],
        contentType: [, output.headers["content-type"]],
        messages: [, output.headers["x-amz-lex-messages"]],
        interpretations: [, output.headers["x-amz-lex-interpretations"]],
        sessionState: [, output.headers["x-amz-lex-session-state"]],
        requestAttributes: [, output.headers["x-amz-lex-request-attributes"]],
        sessionId: [, output.headers["x-amz-lex-session-id"]],
        inputTranscript: [, output.headers["x-amz-lex-input-transcript"]],
        recognizedBotMember: [, output.headers["x-amz-lex-recognized-bot-member"]],
    });
    const data = output.body;
    context.sdkStreamMixin(data);
    contents.audioStream = data;
    return contents;
};
const de_RecognizeUtteranceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.lexruntimev2#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadGatewayException":
        case "com.amazonaws.lexruntimev2#BadGatewayException":
            throw await de_BadGatewayExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.lexruntimev2#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "DependencyFailedException":
        case "com.amazonaws.lexruntimev2#DependencyFailedException":
            throw await de_DependencyFailedExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.lexruntimev2#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.lexruntimev2#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.lexruntimev2#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.lexruntimev2#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
export const de_StartConversationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_StartConversationCommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = output.body;
    contents.responseEventStream = de_StartConversationResponseEventStream(data, context);
    return contents;
};
const de_StartConversationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.lexruntimev2#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.lexruntimev2#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.lexruntimev2#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.lexruntimev2#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_BadGatewayExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new BadGatewayException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_DependencyFailedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new DependencyFailedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_StartConversationRequestEventStream = (input, context) => {
    const eventMarshallingVisitor = (event) => StartConversationRequestEventStream.visit(event, {
        ConfigurationEvent: (value) => se_ConfigurationEvent_event(value, context),
        AudioInputEvent: (value) => se_AudioInputEvent_event(value, context),
        DTMFInputEvent: (value) => se_DTMFInputEvent_event(value, context),
        TextInputEvent: (value) => se_TextInputEvent_event(value, context),
        PlaybackCompletionEvent: (value) => se_PlaybackCompletionEvent_event(value, context),
        DisconnectionEvent: (value) => se_DisconnectionEvent_event(value, context),
        _: (value) => value,
    });
    return context.eventStreamMarshaller.serialize(input, eventMarshallingVisitor);
};
const se_AudioInputEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "AudioInputEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/json" },
    };
    let body = new Uint8Array();
    body = se_AudioInputEvent(input, context);
    body = context.utf8Decoder(JSON.stringify(body));
    return { headers, body };
};
const se_ConfigurationEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "ConfigurationEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/json" },
    };
    let body = new Uint8Array();
    body = se_ConfigurationEvent(input, context);
    body = context.utf8Decoder(JSON.stringify(body));
    return { headers, body };
};
const se_DisconnectionEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "DisconnectionEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/json" },
    };
    let body = new Uint8Array();
    body = _json(input);
    body = context.utf8Decoder(JSON.stringify(body));
    return { headers, body };
};
const se_DTMFInputEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "DTMFInputEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/json" },
    };
    let body = new Uint8Array();
    body = _json(input);
    body = context.utf8Decoder(JSON.stringify(body));
    return { headers, body };
};
const se_PlaybackCompletionEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "PlaybackCompletionEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/json" },
    };
    let body = new Uint8Array();
    body = _json(input);
    body = context.utf8Decoder(JSON.stringify(body));
    return { headers, body };
};
const se_TextInputEvent_event = (input, context) => {
    const headers = {
        ":event-type": { type: "string", value: "TextInputEvent" },
        ":message-type": { type: "string", value: "event" },
        ":content-type": { type: "string", value: "application/json" },
    };
    let body = new Uint8Array();
    body = _json(input);
    body = context.utf8Decoder(JSON.stringify(body));
    return { headers, body };
};
const de_StartConversationResponseEventStream = (output, context) => {
    return context.eventStreamMarshaller.deserialize(output, async (event) => {
        if (event["PlaybackInterruptionEvent"] != null) {
            return {
                PlaybackInterruptionEvent: await de_PlaybackInterruptionEvent_event(event["PlaybackInterruptionEvent"], context),
            };
        }
        if (event["TranscriptEvent"] != null) {
            return {
                TranscriptEvent: await de_TranscriptEvent_event(event["TranscriptEvent"], context),
            };
        }
        if (event["IntentResultEvent"] != null) {
            return {
                IntentResultEvent: await de_IntentResultEvent_event(event["IntentResultEvent"], context),
            };
        }
        if (event["TextResponseEvent"] != null) {
            return {
                TextResponseEvent: await de_TextResponseEvent_event(event["TextResponseEvent"], context),
            };
        }
        if (event["AudioResponseEvent"] != null) {
            return {
                AudioResponseEvent: await de_AudioResponseEvent_event(event["AudioResponseEvent"], context),
            };
        }
        if (event["HeartbeatEvent"] != null) {
            return {
                HeartbeatEvent: await de_HeartbeatEvent_event(event["HeartbeatEvent"], context),
            };
        }
        if (event["AccessDeniedException"] != null) {
            return {
                AccessDeniedException: await de_AccessDeniedException_event(event["AccessDeniedException"], context),
            };
        }
        if (event["ResourceNotFoundException"] != null) {
            return {
                ResourceNotFoundException: await de_ResourceNotFoundException_event(event["ResourceNotFoundException"], context),
            };
        }
        if (event["ValidationException"] != null) {
            return {
                ValidationException: await de_ValidationException_event(event["ValidationException"], context),
            };
        }
        if (event["ThrottlingException"] != null) {
            return {
                ThrottlingException: await de_ThrottlingException_event(event["ThrottlingException"], context),
            };
        }
        if (event["InternalServerException"] != null) {
            return {
                InternalServerException: await de_InternalServerException_event(event["InternalServerException"], context),
            };
        }
        if (event["ConflictException"] != null) {
            return {
                ConflictException: await de_ConflictException_event(event["ConflictException"], context),
            };
        }
        if (event["DependencyFailedException"] != null) {
            return {
                DependencyFailedException: await de_DependencyFailedException_event(event["DependencyFailedException"], context),
            };
        }
        if (event["BadGatewayException"] != null) {
            return {
                BadGatewayException: await de_BadGatewayException_event(event["BadGatewayException"], context),
            };
        }
        return { $unknown: output };
    });
};
const de_AccessDeniedException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_AccessDeniedExceptionRes(parsedOutput, context);
};
const de_AudioResponseEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, de_AudioResponseEvent(data, context));
    return contents;
};
const de_BadGatewayException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_BadGatewayExceptionRes(parsedOutput, context);
};
const de_ConflictException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_ConflictExceptionRes(parsedOutput, context);
};
const de_DependencyFailedException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_DependencyFailedExceptionRes(parsedOutput, context);
};
const de_HeartbeatEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, _json(data));
    return contents;
};
const de_IntentResultEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, de_IntentResultEvent(data, context));
    return contents;
};
const de_InternalServerException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_InternalServerExceptionRes(parsedOutput, context);
};
const de_PlaybackInterruptionEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, _json(data));
    return contents;
};
const de_ResourceNotFoundException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_ResourceNotFoundExceptionRes(parsedOutput, context);
};
const de_TextResponseEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, _json(data));
    return contents;
};
const de_ThrottlingException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_ThrottlingExceptionRes(parsedOutput, context);
};
const de_TranscriptEvent_event = async (output, context) => {
    const contents = {};
    const data = await parseBody(output.body, context);
    Object.assign(contents, _json(data));
    return contents;
};
const de_ValidationException_event = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    return de_ValidationExceptionRes(parsedOutput, context);
};
const se_AudioInputEvent = (input, context) => {
    return take(input, {
        audioChunk: context.base64Encoder,
        clientTimestampMillis: [],
        contentType: [],
        eventId: [],
    });
};
const se_ConfigurationEvent = (input, context) => {
    return take(input, {
        clientTimestampMillis: [],
        disablePlayback: [],
        eventId: [],
        requestAttributes: _json,
        responseContentType: [],
        sessionState: (_) => se_SessionState(_, context),
        welcomeMessages: _json,
    });
};
const se_DialogAction = (input, context) => {
    return take(input, {
        slotElicitationStyle: [],
        slotToElicit: [],
        subSlotToElicit: (_) => se_ElicitSubSlot(_, context),
        type: [],
    });
};
const se_ElicitSubSlot = (input, context) => {
    return take(input, {
        name: [],
        subSlotToElicit: (_) => se_ElicitSubSlot(_, context),
    });
};
const se_Intent = (input, context) => {
    return take(input, {
        confirmationState: [],
        name: [],
        slots: (_) => se_Slots(_, context),
        state: [],
    });
};
const se_RuntimeHintDetails = (input, context) => {
    return take(input, {
        runtimeHintValues: _json,
        subSlotHints: (_) => se_SlotHintsSlotMap(_, context),
    });
};
const se_RuntimeHints = (input, context) => {
    return take(input, {
        slotHints: (_) => se_SlotHintsIntentMap(_, context),
    });
};
const se_SessionState = (input, context) => {
    return take(input, {
        activeContexts: _json,
        dialogAction: (_) => se_DialogAction(_, context),
        intent: (_) => se_Intent(_, context),
        originatingRequestId: [],
        runtimeHints: (_) => se_RuntimeHints(_, context),
        sessionAttributes: _json,
    });
};
const se_Slot = (input, context) => {
    return take(input, {
        shape: [],
        subSlots: (_) => se_Slots(_, context),
        value: _json,
        values: (_) => se_Values(_, context),
    });
};
const se_SlotHintsIntentMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_SlotHintsSlotMap(value, context);
        return acc;
    }, {});
};
const se_SlotHintsSlotMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_RuntimeHintDetails(value, context);
        return acc;
    }, {});
};
const se_Slots = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_Slot(value, context);
        return acc;
    }, {});
};
const se_Values = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Slot(entry, context);
    });
};
const de_AudioResponseEvent = (output, context) => {
    return take(output, {
        audioChunk: context.base64Decoder,
        contentType: __expectString,
        eventId: __expectString,
    });
};
const de_ConfidenceScore = (output, context) => {
    return take(output, {
        score: __limitedParseDouble,
    });
};
const de_DialogAction = (output, context) => {
    return take(output, {
        slotElicitationStyle: __expectString,
        slotToElicit: __expectString,
        subSlotToElicit: (_) => de_ElicitSubSlot(_, context),
        type: __expectString,
    });
};
const de_ElicitSubSlot = (output, context) => {
    return take(output, {
        name: __expectString,
        subSlotToElicit: (_) => de_ElicitSubSlot(_, context),
    });
};
const de_Intent = (output, context) => {
    return take(output, {
        confirmationState: __expectString,
        name: __expectString,
        slots: (_) => de_Slots(_, context),
        state: __expectString,
    });
};
const de_IntentResultEvent = (output, context) => {
    return take(output, {
        eventId: __expectString,
        inputMode: __expectString,
        interpretations: (_) => de_Interpretations(_, context),
        recognizedBotMember: _json,
        requestAttributes: _json,
        sessionId: __expectString,
        sessionState: (_) => de_SessionState(_, context),
    });
};
const de_Interpretation = (output, context) => {
    return take(output, {
        intent: (_) => de_Intent(_, context),
        nluConfidence: (_) => de_ConfidenceScore(_, context),
        sentimentResponse: (_) => de_SentimentResponse(_, context),
    });
};
const de_Interpretations = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Interpretation(entry, context);
    });
    return retVal;
};
const de_RuntimeHintDetails = (output, context) => {
    return take(output, {
        runtimeHintValues: _json,
        subSlotHints: (_) => de_SlotHintsSlotMap(_, context),
    });
};
const de_RuntimeHints = (output, context) => {
    return take(output, {
        slotHints: (_) => de_SlotHintsIntentMap(_, context),
    });
};
const de_SentimentResponse = (output, context) => {
    return take(output, {
        sentiment: __expectString,
        sentimentScore: (_) => de_SentimentScore(_, context),
    });
};
const de_SentimentScore = (output, context) => {
    return take(output, {
        mixed: __limitedParseDouble,
        negative: __limitedParseDouble,
        neutral: __limitedParseDouble,
        positive: __limitedParseDouble,
    });
};
const de_SessionState = (output, context) => {
    return take(output, {
        activeContexts: _json,
        dialogAction: (_) => de_DialogAction(_, context),
        intent: (_) => de_Intent(_, context),
        originatingRequestId: __expectString,
        runtimeHints: (_) => de_RuntimeHints(_, context),
        sessionAttributes: _json,
    });
};
const de_Slot = (output, context) => {
    return take(output, {
        shape: __expectString,
        subSlots: (_) => de_Slots(_, context),
        value: _json,
        values: (_) => de_Values(_, context),
    });
};
const de_SlotHintsIntentMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_SlotHintsSlotMap(value, context);
        return acc;
    }, {});
};
const de_SlotHintsSlotMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_RuntimeHintDetails(value, context);
        return acc;
    }, {});
};
const de_Slots = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_Slot(value, context);
        return acc;
    }, {});
};
const de_Values = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Slot(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
